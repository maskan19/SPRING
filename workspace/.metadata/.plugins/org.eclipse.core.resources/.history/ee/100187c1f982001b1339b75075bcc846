package kr.or.ddit.servlet01;

import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebInitParam;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet : 자바를 기반으로 웹 어플리케이션을 구현하기 위한 명세 혹은 그 명세에 따른 API모음
 * 
 * 개발 단계
 * 1. HttpServlet의 구현체로 서블릿 소스 작성
 * 2. WEB-INF / classes(context classpath)에 컴파일 후 클래스파일 배포
 * 3. 컨테이너에 서블릿을 등록
 * 		1) 2.x :web.xml을 이용
 * 				servlet > servlet-name, servlet-class
 * 		2) since 3.xc : (annotation) CoC(Convention over Configuration)
 *  			servlet > servlet-name(어노테이션 이후 괄호 속에 지정 가능, 생략시 클래스명), servlet-class(어노테이션 된 클래스명)
 *  4. 서블릿 매핑으로 웹 상의 명령(URI)을 받을 수 있도록 연결
 *  	1) 2.x : web.xml에 다시 반환
 *  			servlet-mapping > servlet-name, url-pattern
 *  	2) 3.x : @WebServlet(value, urlPatterns)     **value 와 urlPatterns는 동일하다.
 *  5. 컨테이너 재구동
 *  
 *  	** Servlet Container의 역할 : servlet의 lifecycle 관리자
 *  		container : 컨테이너 내부에서 관리되는 컴포넌트의 생명주기 관리자
 *  
 *  		생성 : init
 *  		요청 : service, do%
 *  		소멸 : destroy
 *  
 *  		서블릿 관리 정책
 *  		1. 특별한 설정(loadOnStartup)이 없는 한 해당 서블릿에 매핑된 최초의 요청이 발생하면, 인스턴스 생성
 *  		(서블릿이 생성되는 시점을 임의 변경할 수 있다. loadOnStartup=1 : 서버 시작과 동시에 생성)
 *  		2. 서블릿 초기화 단계에서 초기화 파라미터 전달(init-param)
 *  
 *  		** ServletConfig : 서블릿의 메타 정보를 캡슐화한 객체
 *  
 *  
 *  
 *  
 */

//@WebServlet(loadOnStartup=1, value="/desc.do", initParams = {@WebInitParam(name="paramName", value="paramValue")})
public class DescriptionServlet extends HttpServlet{

	@Override
	public void init(ServletConfig config) throws ServletException {
		// TODO Auto-generated method stub
		super.init(config);
		String param = config.getInitParameter("paramName");
		System.out.printf("%s 서블릿 초기화, 전달 파라미터 : %s\n", this.getClass().getName(), param); 
		//this : DescriptionServlet  .getName() : qualified name
	}
//위의 함수가 우선 순위가 높으며 둘 모두 존재할 경우 위의 함수만 실행된다.
//	@Override
//	public void init() throws ServletException {
//		// TODO Auto-generated method stub
//		super.init();
//	}
	
//	@Override
//	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
//		// TODO Auto-generated method stub
//		super.service(req, res);
//	}

	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// HTTP요청을 받아서 doXXX 메소드로 분기함
		System.out.println("요청 접수, 메소드 판단");
//		super.service(req, resp);
	}
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		// super.doGet(req, resp); 에러 발생
		//확장 CGI방식: 여러 쓰레드를 사용해서 요청을 처리하는 방식
		//쓰레드풀링: 종료된 쓰레드를 재활용, 메모리 공간을 한정할 수 있다.
		System.out.printf("특정 메소드(GET)를 처리할 수 있는 callback, thread name: %s\n", Thread.currentThread().getName());
	}
	
	
	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		super.destroy();
		System.out.printf("%s 객체 소멸", DescriptionServlet.class.getName());//객체를 소멸시키는 것은 JVM의 권한
	}
	
}
